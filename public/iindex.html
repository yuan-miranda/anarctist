<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Anarchy Canvas Sketch</title>
    <link rel="stylesheet" href="https://unpkg.com/kursor/dist/kursor.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;

            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        body {
            font-family: Arial, Helvetica, sans-serif;
            background: #f0f0f0;
            user-select: none;
        }

        h1 {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1;
            margin: 1rem;
            color: #333;
        }

        #container {
            cursor: none;
        }

        img {
            pointer-events: none;
        }

        .link-actions {
            position: fixed;
            margin: 1rem;
            z-index: 1;
            bottom: 10px;
            right: 10px;
        }

        .canvas-actions,
        .link-actions,
        .zoom-actions,
        .color-actions {
            position: fixed;
            margin: 1rem;
            z-index: 1;
        }

        .zoom-actions {
            bottom: 10px;
            left: 10px;
        }

        .canvas-actions button,
        .zoom-actions button,
        .canvas-actions-minified button {
            padding: 0.8rem 1rem;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .kursor--5,
        .kursorChild--5 {
            transition: none !important;
        }

        .kursor--5.kursor--down {
            width: 10px !important;
            height: 10px !important;
        }
    </style>
</head>

<body>
    <h1>Anarctist</h1>
    <div id="container"></div>

    <div id="controls" style="display: none;">
        <input type="range" id="strokeSize" min="1" max="10" value="5">
        <span id="strokeLabel"></span>
    </div>

    <div class="link-actions">
        <a href="https://github.com/yuan-miranda/crystel" target="_blank" aria-label="GitHub Repository">
            <img src="media/icon/github-mark.svg" alt="GitHub" width="32" height="32" title="GitHub Repository">
        </a>
    </div>

    <div class="zoom-actions">
        <button id="zoomIn" title="Zoom In">
            <img src="media/icon/zoomIn.svg" alt="Zoom In" width="24" height="24">
        </button>
        <button id="zoomOut" title="Zoom Out">
            <img src="media/icon/zoomOut.svg" alt="Zoom Out" width="24" height="24">
        </button>
    </div>

    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/kursor"></script>
    <script>
        new kursor({ type: 5, removeDefaultCursor: true });

        Konva.pixelRatio = 1;
        const stage = new Konva.Stage({
            container: 'container',
            width: window.innerWidth,
            height: window.innerHeight
        });

        const layer = new Konva.Layer();
        stage.add(layer);

        const PAGE_WIDTH = 524288;
        const PAGE_HEIGHT = 524288;

        const pageGroup = new Konva.Group({
            clip: { x: 0, y: 0, width: PAGE_WIDTH, height: PAGE_HEIGHT },
        });

        const page = new Konva.Rect({
            x: 0,
            y: 0,
            width: PAGE_WIDTH,
            height: PAGE_HEIGHT,
            fill: '#fff',
            stroke: '#ccc',
            strokeWidth: 2,
        });

        pageGroup.add(page);
        layer.add(pageGroup);

        const strokeInput = document.getElementById("strokeSize");
        const strokeLabel = document.getElementById("strokeLabel");
        let strokeSize = parseInt(strokeInput.value, 10);

        const updateStrokeLabel = () => strokeLabel.textContent = `Stroke: ${strokeSize}px`;
        updateStrokeLabel();

        strokeInput.addEventListener("input", () => {
            strokeSize = parseInt(strokeInput.value, 10);
            updateStrokeLabel();
            cursorCircle.radius(strokeSize / 2);
            layer.batchDraw();
        });

        const cursorCircle = new Konva.Circle({
            radius: strokeSize / 2,
            fill: 'rgba(0,0,0,0.06)',
            listening: false,
            visible: false
        });
        layer.add(cursorCircle);
        cursorCircle.moveToTop();

        let isDrawing = false;
        let currentLine = null;

        const getPointerPos = () => {
            const transform = stage.getAbsoluteTransform().copy();
            transform.invert();
            return transform.point(stage.getPointerPosition());
        };

        const endDrawing = () => {
            isDrawing = false;
            currentLine = null;
        };

        stage.container().addEventListener('contextmenu', e => e.preventDefault());

        stage.on('mousedown touchstart', (e) => {
            const pos = getPointerPos();
            if (e.evt.button === 0) {
                isDrawing = true;
                currentLine = new Konva.Line({
                    stroke: 'black',
                    strokeWidth: strokeSize,
                    globalCompositeOperation: 'source-over',
                    points: [pos.x, pos.y, pos.x, pos.y],
                    lineCap: 'round',
                    lineJoin: 'round',
                });
                pageGroup.add(currentLine);
            } else if (e.evt.button === 2) {
                stage.draggable(true);
                stage.startDrag();
            }
        });

        stage.on('mousemove touchmove', () => {
            const pos = getPointerPos();
            if (!pos) return;

            cursorCircle.position(pos);
            cursorCircle.visible(true);

            if (isDrawing && currentLine) {
                currentLine.points(currentLine.points().concat([pos.x, pos.y]));
            }

            layer.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (e.evt.button === 0) endDrawing();
            else if (e.evt.button === 2) stage.draggable(false);
        });

        stage.on('mouseleave', () => { cursorCircle.visible(false); endDrawing(); });
        window.addEventListener('blur', endDrawing);

        window.addEventListener('resize', () => {
            stage.width(window.innerWidth);
            stage.height(window.innerHeight);
            stage.batchDraw();
        });

        let zoomInterval = null;
        const zoomSpeed = 1.02;
        const zoomDelay = 1000;

        function zoomStageAtCenter(scaleFactor) {
            const oldScale = stage.scaleX();
            const pointer = {
                x: stage.width() / 2,
                y: stage.height() / 2
            };

            const mousePointTo = {
                x: (pointer.x - stage.x()) / oldScale,
                y: (pointer.y - stage.y()) / oldScale
            };

            const newScale = oldScale * scaleFactor;

            stage.scale({ x: newScale, y: newScale });
            stage.position({
                x: pointer.x - mousePointTo.x * newScale,
                y: pointer.y - mousePointTo.y * newScale
            });

            stage.batchDraw();
        }

        function startZoom(scaleFactor) {
            if (zoomInterval) {
                clearInterval(zoomInterval);
            }
            zoomInterval = setInterval(() => {
                zoomStageAtCenter(scaleFactor);
            }, zoomDelay);
        }

        function stopZoom() {
            if (zoomInterval) {
                clearInterval(zoomInterval);
                alert('zoom stopped');
            }
            zoomInterval = null;
        }

        // zoom in
        const zoomInBtn = document.getElementById('zoomIn');
        zoomInBtn.addEventListener('mousedown', () => startZoom(zoomSpeed));
        zoomInBtn.addEventListener('touchstart', () => startZoom(zoomSpeed));
        zoomInBtn.addEventListener('mouseup', stopZoom);
        zoomInBtn.addEventListener('mouseleave', stopZoom);
        zoomInBtn.addEventListener('touchend', () => {
            stopZoom();
            alert('touch end zoom in');
        });

        // zoom out
        const zoomOutBtn = document.getElementById('zoomOut');
        zoomOutBtn.addEventListener('mousedown', () => startZoom(1 / zoomSpeed));
        zoomOutBtn.addEventListener('touchstart', () => startZoom(1 / zoomSpeed));
        zoomOutBtn.addEventListener('mouseup', stopZoom);
        zoomOutBtn.addEventListener('mouseleave', stopZoom);
        zoomOutBtn.addEventListener('touchend', () => {
            stopZoom();
            alert('touch end zoom out');
        });

        // two-finger panning
        let isTwoFingerPanning = false;
        let lastCenter = null;

        function getCenter(t1, t2) {
            return {
                x: (t1.clientX + t2.clientX) / 2,
                y: (t1.clientY + t2.clientY) / 2
            };
        }

        stage.getContent().addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                isTwoFingerPanning = true;
                lastCenter = getCenter(e.touches[0], e.touches[1]);

                // stop drawing if we were
                isDrawing = false;
                currentLine = null;
            }
        }, { passive: false });

        stage.getContent().addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && isTwoFingerPanning) {
                e.preventDefault();

                const center = getCenter(e.touches[0], e.touches[1]);
                const dx = center.x - lastCenter.x;
                const dy = center.y - lastCenter.y;

                stage.position({
                    x: stage.x() + dx,
                    y: stage.y() + dy
                });

                stage.batchDraw();
                lastCenter = center;
            }
        }, { passive: false });

        stage.getContent().addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                isTwoFingerPanning = false;
                lastCenter = null;
            }
        });
    </script>

</body>

</html>