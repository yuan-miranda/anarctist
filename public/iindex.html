<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Konva Whiteboard (Finite Page)</title>
    <link rel="stylesheet" href="https://unpkg.com/kursor/dist/kursor.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
            background: #e5e5e5;
            cursor: none;
        }

        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }

        #strokeSize {
            width: 120px;
        }

        #strokeLabel {
            display: block;
            text-align: center;
            font-size: 14px;
            margin-top: 4px;
        }

        .kursor--5,
        .kursorChild--5 {
            transition: none !important;
        }

        .kursor--5.kursor--down {
            width: 10px !important;
            height: 10px !important;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <div id="controls">
        <input type="range" id="strokeSize" min="1" max="10" value="5">
        <span id="strokeLabel"></span>
    </div>

    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/kursor"></script>
    <script>
        new kursor({ type: 5, removeDefaultCursor: true });

        Konva.pixelRatio = 1;
        const stage = new Konva.Stage({
            container: 'container',
            width: window.innerWidth,
            height: window.innerHeight
        });

        const layer = new Konva.Layer();
        stage.add(layer);

        const PAGE_WIDTH = 524288;
        const PAGE_HEIGHT = 524288;

        const pageGroup = new Konva.Group({
            clip: { x: 0, y: 0, width: PAGE_WIDTH, height: PAGE_HEIGHT },
        });

        const page = new Konva.Rect({
            x: 0,
            y: 0,
            width: PAGE_WIDTH,
            height: PAGE_HEIGHT,
            fill: '#fff',
            stroke: '#ccc',
            strokeWidth: 2,
        });

        pageGroup.add(page);
        layer.add(pageGroup);

        const strokeInput = document.getElementById("strokeSize");
        const strokeLabel = document.getElementById("strokeLabel");
        let strokeSize = parseInt(strokeInput.value, 10);

        const updateStrokeLabel = () => strokeLabel.textContent = `Stroke: ${strokeSize}px`;
        updateStrokeLabel();

        strokeInput.addEventListener("input", () => {
            strokeSize = parseInt(strokeInput.value, 10);
            updateStrokeLabel();
            cursorCircle.radius(strokeSize / 2);
            layer.batchDraw();
        });

        const cursorCircle = new Konva.Circle({
            radius: strokeSize / 2,
            fill: 'rgba(0,0,0,0.06)',
            listening: false,
            visible: false
        });
        layer.add(cursorCircle);
        cursorCircle.moveToTop();

        let isDrawing = false;
        let currentLine = null;

        const getPointerPos = () => {
            const transform = stage.getAbsoluteTransform().copy();
            transform.invert();
            return transform.point(stage.getPointerPosition());
        };

        const endDrawing = () => {
            isDrawing = false;
            currentLine = null;
        };

        stage.container().addEventListener('contextmenu', e => e.preventDefault());

        stage.on('mousedown touchstart', (e) => {
            const pos = getPointerPos();
            if (e.evt.button === 0) {
                isDrawing = true;
                currentLine = new Konva.Line({
                    stroke: 'black',
                    strokeWidth: strokeSize,
                    globalCompositeOperation: 'source-over',
                    points: [pos.x, pos.y, pos.x, pos.y],
                    lineCap: 'round',
                    lineJoin: 'round',
                });
                pageGroup.add(currentLine);
            } else if (e.evt.button === 2) {
                stage.draggable(true);
                stage.startDrag();
            }
        });

        stage.on('mousemove touchmove', () => {
            const pos = getPointerPos();
            if (!pos) return;

            cursorCircle.position(pos);
            cursorCircle.visible(true);

            if (isDrawing && currentLine) {
                currentLine.points(currentLine.points().concat([pos.x, pos.y]));
            }

            layer.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (e.evt.button === 0) endDrawing();
            else if (e.evt.button === 2) stage.draggable(false);
        });

        stage.on('mouseleave', () => { cursorCircle.visible(false); endDrawing(); });
        window.addEventListener('blur', endDrawing);


        stage.on('wheel', (e) => {
            e.evt.preventDefault();

            if (!e.evt.ctrlKey) return;

            const scaleBy = 1.02;
            const oldScale = stage.scaleX();
            const pointer = stage.getPointerPosition();

            const mousePointTo = {
                x: (pointer.x - stage.x()) / oldScale,
                y: (pointer.y - stage.y()) / oldScale
            };

            const newScale = e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;
            stage.scale({ x: newScale, y: newScale });

            stage.position({
                x: pointer.x - mousePointTo.x * newScale,
                y: pointer.y - mousePointTo.y * newScale
            });

            stage.batchDraw();
        });






        let lastTouchDistance = 0;
        let lastTouchMidpoint = null;
        let isPanning = false;

        function getDistance(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getMidpoint(t1, t2) {
            return {
                x: (t1.clientX + t2.clientX) / 2,
                y: (t1.clientY + t2.clientY) / 2
            };
        }

        stage.container().addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                // One finger → start drawing
                const pos = getPointerPos();
                if (!pos) return;

                isDrawing = true;
                currentLine = new Konva.Line({
                    stroke: 'black',
                    strokeWidth: strokeSize,
                    globalCompositeOperation: 'source-over',
                    points: [pos.x, pos.y, pos.x, pos.y],
                    lineCap: 'round',
                    lineJoin: 'round',
                });
                pageGroup.add(currentLine);
            } else if (e.touches.length === 2) {
                // Two fingers → start pan/zoom
                isPanning = true;
                lastTouchDistance = getDistance(e.touches[0], e.touches[1]);
                lastTouchMidpoint = getMidpoint(e.touches[0], e.touches[1]);
            }
        }, { passive: false });

        stage.container().addEventListener('touchmove', e => {
            if (e.touches.length === 1 && isDrawing && currentLine) {
                e.preventDefault();
                // Drawing with one finger
                const pos = getPointerPos();
                if (!pos) return;

                cursorCircle.position(pos);
                cursorCircle.visible(true);
                currentLine.points(currentLine.points().concat([pos.x, pos.y]));
                layer.batchDraw();
            } else if (e.touches.length >= 2 && isPanning) {
                e.preventDefault();
                // Pan & pinch zoom with two fingers
                const midpoint = getMidpoint(e.touches[0], e.touches[1]);
                const distance = getDistance(e.touches[0], e.touches[1]);

                // Zoom
                const oldScale = stage.scaleX();
                const scaleChange = distance / lastTouchDistance;
                const mousePointTo = {
                    x: (midpoint.x - stage.x()) / oldScale,
                    y: (midpoint.y - stage.y()) / oldScale
                };
                const newScale = oldScale * scaleChange;
                stage.scale({ x: newScale, y: newScale });

                // Pan
                const dx = midpoint.x - lastTouchMidpoint.x;
                const dy = midpoint.y - lastTouchMidpoint.y;
                stage.position({
                    x: stage.x() + dx,
                    y: stage.y() + dy
                });

                stage.batchDraw();

                lastTouchDistance = distance;
                lastTouchMidpoint = midpoint;
            }
        }, { passive: false });

        stage.container().addEventListener('touchend', e => {
            if (e.touches.length < 2) {
                isPanning = false;
                lastTouchDistance = 0;
                lastTouchMidpoint = null;
            }
            if (e.touches.length === 0) {
                isDrawing = false;
                currentLine = null;
            }
        }, { passive: false });







        window.addEventListener('resize', () => {
            stage.width(window.innerWidth);
            stage.height(window.innerHeight);
            stage.batchDraw();
        });
    </script>
</body>

</html>